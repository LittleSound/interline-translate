diff --git a/dist/cli.mjs b/dist/cli.mjs
index 1613a8f46f313b6e69483c79a7c27f431d89c348..a756b00f766a0a73b292d103b4368b94a73b698a 100644
--- a/dist/cli.mjs
+++ b/dist/cli.mjs
@@ -3,14 +3,16 @@ import cac from 'cac';
 import { generate } from './index.mjs';
 import 'scule';
 
-const version = "0.0.0";
+const version = "0.2.0";
 
 const cli = cac().version(version);
-cli.command("[input]", "Generate TypeScript files from package.json").option("--output <output>", "Output file", { default: "src/generated-meta.ts" }).action(async (input = "package.json", options) => {
+cli.command("[input]", "Generate TypeScript files from package.json").option("--output <output>", "Output file", { default: "src/generated-meta.ts" }).option("--namespace <namespace>", "Generate with namespace").action(async (input = "package.json", options) => {
   const json = JSON.parse(await fs.readFile(input, "utf-8"));
   if (!json.publisher)
     throw new Error("This package.json does not seem to be a valid VSCode extension package.json");
-  const file = await generate(json);
+  const file = await generate(json, {
+    namespace: options.namespace === "false" ? false : options.namespace
+  });
   await fs.writeFile(options.output, file, "utf-8");
 });
 cli.help();
diff --git a/dist/index.d.mts b/dist/index.d.mts
index f436522689d022004e826df13554f5583c21c845..43ec3931fbd5a11e308b994d19ad958cbfa64937 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,3 +1,14 @@
-declare function generate(packageJson: any): string;
+interface GenerateOptions {
+    /**
+     * The header of the generated file
+     */
+    header?: string | boolean;
+    /**
+     * Use namespace for generated types
+     * @default false
+     */
+    namespace?: string | boolean;
+}
+declare function generate(packageJson: any, options?: GenerateOptions): string;
 
-export { generate };
+export { type GenerateOptions, generate };
diff --git a/dist/index.d.ts b/dist/index.d.ts
index f436522689d022004e826df13554f5583c21c845..43ec3931fbd5a11e308b994d19ad958cbfa64937 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,3 +1,14 @@
-declare function generate(packageJson: any): string;
+interface GenerateOptions {
+    /**
+     * The header of the generated file
+     */
+    header?: string | boolean;
+    /**
+     * Use namespace for generated types
+     * @default false
+     */
+    namespace?: string | boolean;
+}
+declare function generate(packageJson: any, options?: GenerateOptions): string;
 
-export { generate };
+export { type GenerateOptions, generate };
diff --git a/dist/index.mjs b/dist/index.mjs
index 43a81cbaaafc0238e536ecf67fca94f97aa24e2a..a515c9eb9597c4c8df8eaa7ad7bcaac4bbd3f731 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,4 +1,4 @@
-import { pascalCase } from 'scule';
+import { camelCase } from 'scule';
 
 const forwardKeys = [
   "publisher",
@@ -7,22 +7,28 @@ const forwardKeys = [
   "displayName",
   "description"
 ];
-function generate(packageJson) {
-  const lines = [
-    "// This file is generated by `vscode-ext-gen`. Do not modify manually.",
-    "// @see https://github.com/antfu/vscode-ext-gen",
-    ""
-  ];
+function generate(packageJson, options = {}) {
+  let {
+    header = true,
+    namespace = false
+  } = options;
+  let lines = [];
   lines.push("// Meta info");
   for (const key of forwardKeys) {
     lines.push(`export const ${key} = ${packageJson[key] ? JSON.stringify(packageJson[key]) : "undefined"}`);
   }
   lines.push(
     // eslint-disable-next-line no-template-curly-in-string
-    "export const extensionName = `${publisher}.${name}`"
+    "export const extensionId = `${publisher}.${name}`"
   );
-  const namespace = `${packageJson.name}.`;
-  const extensionName = `${packageJson.publisher}.${packageJson.name}`;
+  const extensionPrefix = `${packageJson.name}.`;
+  const extensionId = `${packageJson.publisher}.${packageJson.name}`;
+  function withoutExtensionPrefix(name) {
+    if (name.startsWith(extensionPrefix)) {
+      return name.slice(extensionPrefix.length);
+    }
+    return name;
+  }
   lines.push(
     "",
     ...generateCommentBlock("Type union of all commands")
@@ -39,77 +45,107 @@ function generate(packageJson) {
   }
   lines.push(
     "",
-    ...generateCommentBlock(`Commands map registed by \`${extensionName}\``),
+    ...generateCommentBlock(`Commands map registed by \`${extensionId}\``),
     "export const commands = {",
     ...(packageJson.contributes?.commands || []).flatMap((c) => {
-      let name = c.command;
-      if (name.startsWith(namespace)) {
-        name = name.slice(namespace.length);
-      }
+      const name = withoutExtensionPrefix(c.command);
       return [
         ...generateCommentBlock(`${c.title}
 @value \`${c.command}\``, 2),
-        `  ${pascalCase(name)}: ${JSON.stringify(c.command)},`
+        `  ${camelCase(name)}: ${JSON.stringify(c.command)},`
       ];
     }),
     "} satisfies Record<string, CommandId>"
   );
-  const configurationObject = packageJson.contributes?.configuration?.properties || {};
+  const configsObject = packageJson.contributes?.configuration?.properties || {};
   lines.push(
     "",
-    ...generateCommentBlock("Type union of all configurations")
+    ...generateCommentBlock("Type union of all configs")
   );
-  if (!Object.keys(configurationObject).length) {
-    lines.push("export type ConfigurationId = never");
+  if (!Object.keys(configsObject).length) {
+    lines.push("export type ConfigKey = never");
   } else {
     lines.push(
-      "export type ConfigurationId = ",
-      ...Object.keys(configurationObject).map(
+      "export type ConfigKey = ",
+      ...Object.keys(configsObject).map(
         (c) => `  | "${c}"`
       )
     );
   }
   lines.push(
     "",
-    ...generateCommentBlock(`Configs map registed by \`${extensionName}\``),
-    "export const configurations = {",
-    ...Object.entries(configurationObject).flatMap(([key, value]) => {
-      let name = key;
-      if (name.startsWith(namespace)) {
-        name = name.slice(namespace.length);
-      }
+    "export interface ConfigKeyTypeMap {",
+    ...Object.entries(configsObject).flatMap(([key, value]) => {
       return [
-        ...generateCommentBlock([
-          value.description,
-          `@key \`${key}\``,
-          `@default \`${JSON.stringify(value.default)}\``,
-          `@type \`${value.type}\``
-        ].join("\n"), 2),
-        `  ${pascalCase(name)}: "${key}",`
+        `  ${JSON.stringify(key)}: ${typeFromSchema(value)},`
       ];
     }),
-    "} satisfies Record<string, ConfigurationId>"
+    "}"
   );
   lines.push(
     "",
-    "export const configurationsDefaults = {",
-    ...Object.entries(configurationObject).flatMap(([key, value]) => {
+    "export interface ConfigShorthandMap {",
+    ...Object.entries(configsObject).flatMap(([key]) => {
       return [
-        `  ${JSON.stringify(key)}: ${JSON.stringify(value.default)},`
+        `  ${JSON.stringify(withoutExtensionPrefix(key))}: ${JSON.stringify(key)},`
       ];
     }),
-    "} satisfies { [key in ConfigurationId]: ConfigurationTypeMap[key] | null | undefined }"
+    "}"
+  );
+  lines.push(
+    "",
+    `export interface ConfigMeta<T extends keyof ConfigKeyTypeMap> {`,
+    `  key: T,`,
+    `  default: ConfigKeyTypeMap[T],`,
+    `}`,
+    ""
   );
   lines.push(
     "",
-    "export interface ConfigurationTypeMap {",
-    ...Object.entries(configurationObject).flatMap(([key, value]) => {
+    ...generateCommentBlock(`Configs map registed by \`${extensionId}\``),
+    "export const configs = {",
+    ...Object.entries(configsObject).flatMap(([key, value]) => {
+      const name = withoutExtensionPrefix(key);
       return [
-        `  ${JSON.stringify(key)}: ${typeFromSchema(value)},`
+        ...generateCommentBlock([
+          value.description,
+          `@key \`${key}\``,
+          `@default \`${JSON.stringify(value.default)}\``,
+          `@type \`${value.type}\``
+        ].join("\n"), 2),
+        `  ${camelCase(name)}: {`,
+        `    key: "${key}",`,
+        `    default: ${JSON.stringify(value.default)},`,
+        `  } as ConfigMeta<"${key}">,`
       ];
     }),
     "}"
   );
+  if (namespace) {
+    if (namespace === true)
+      namespace = "ExtensionMeta";
+    lines = lines.map((line) => line ? `  ${line}` : line);
+    lines.unshift(
+      ...generateCommentBlock(`Extension Meta for \`${extensionId}\``, 0),
+      `export namespace ${namespace} {`
+    );
+    lines.push(
+      "}",
+      "",
+      `export default ${namespace}`
+    );
+  }
+  if (header) {
+    if (typeof header === "string") {
+      lines.unshift(header);
+    } else {
+      lines.unshift(
+        "// This file is generated by `vscode-ext-gen`. Do not modify manually.",
+        "// @see https://github.com/antfu/vscode-ext-gen",
+        ""
+      );
+    }
+  }
   lines.push("");
   return lines.join("\n");
 }
@@ -117,41 +153,58 @@ function generateCommentBlock(text, padding = 0) {
   const indent = " ".repeat(padding);
   if (!text) {
     return [];
-  } else if (!text.includes("\n")) {
-    return [
-      `${indent}/** ${text} */`
-    ];
-  } else {
-    return [
-      `${indent}/**`,
-      text.split("\n").map((l) => `${indent} * ${l}`).join("\n"),
-      `${indent} */`
-    ];
   }
+  return [
+    `${indent}/**`,
+    ...text.split(/\n/g).map((l) => `${indent} * ${l}`),
+    `${indent} */`
+  ];
 }
-function typeFromSchema(schema) {
+function typeFromSchema(schema, isSubType = false) {
   if (!schema)
     return "unknown";
+  const types = [];
   switch (schema.type) {
     case "boolean":
-      return "boolean";
+      types.push("boolean");
+      break;
     case "string":
       if (schema.enum) {
-        return `(${schema.enum.map((v) => JSON.stringify(v)).join(" | ")})`;
+        types.push(...schema.enum.map((v) => JSON.stringify(v)));
+        break;
       }
-      return "string";
+      types.push("string");
+      break;
     case "number":
-      return "number";
+      types.push("number");
+      break;
     case "array":
       if (schema.items) {
-        return `${typeFromSchema(schema.items)}[]`;
+        types.push(`${typeFromSchema(schema.items, true)}[]`);
+        break;
       }
-      return "unknown[]";
+      types.push("unknown[]");
+      break;
     case "object":
-      return "Record<string, unknown>";
+      if (schema.items) {
+        types.push(`Record<string, ${typeFromSchema(schema.items, true)}>`);
+        break;
+      }
+      types.push("Record<string, unknown>");
+      break;
     default:
-      return "unknown";
+      types.push("unknown");
+  }
+  if (!isSubType) {
+    if (!("default" in schema) || schema.default === void 0)
+      types.push("undefined");
+    else if (schema.default === null)
+      types.push("null");
   }
+  if (types.length === 1)
+    return types[0];
+  else
+    return `(${types.join(" | ")})`;
 }
 
 export { generate };
diff --git a/package.json b/package.json
index e75d917a4b9f391c146fd45c512a327b739d1cc1..17ce503d984622728672f9b7d69caa06b7fb2c46 100644
--- a/package.json
+++ b/package.json
@@ -53,9 +53,24 @@
     "devDependencies": {}
   },
   "dependencies": {
-    "cac": "^6.7.14",
-    "scule": "^1.3.0",
-    "yargs": "^17.7.2"
+    "@antfu/eslint-config": "^2.22.0",
+    "@antfu/ni": "^0.21.12",
+    "@antfu/utils": "^0.7.10",
+    "@types/node": "^20.14.10",
+    "@types/yargs": "^17.0.32",
+    "bumpp": "^9.4.1",
+    "eslint": "^9.6.0",
+    "esno": "^4.7.0",
+    "fast-glob": "^3.3.2",
+    "lint-staged": "^15.2.7",
+    "pnpm": "^9.5.0",
+    "rimraf": "^6.0.0",
+    "simple-git-hooks": "^2.11.1",
+    "typescript": "^5.5.3",
+    "unbuild": "^2.0.0",
+    "vite": "^5.3.3",
+    "vitest": "^2.0.1",
+    "taze": "^0.14.2"
   },
   "devDependencies": {
     "@antfu/eslint-config": "^2.22.0",
@@ -74,7 +89,8 @@
     "typescript": "^5.5.3",
     "unbuild": "^2.0.0",
     "vite": "^5.3.3",
-    "vitest": "^2.0.1"
+    "vitest": "^2.0.1",
+    "taze": "^0.14.2"
   },
   "simple-git-hooks": {
     "pre-commit": "pnpm lint-staged"
